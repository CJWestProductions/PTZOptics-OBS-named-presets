declare module 'electron-builder/out/awaiter' {
   var _default: (thisArg: any, _arguments: any, ignored: any, generator: Function) => any
  export = _default
}

declare module 'electron-builder/out/builder' {
  import { Packager } from "electron-builder/out/packager"
  import { PackagerOptions } from "electron-builder/out/platformPackager"
  import { PublishOptions, Publisher } from "electron-builder/out/gitHubPublisher"
  import { InfoRetriever } from "electron-builder/out/repositoryInfo"

  export function createPublisher(packager: Packager, options: BuildOptions, repoSlug: InfoRetriever, isPublishOptionGuessed?: boolean): Promise<Publisher>

  export interface BuildOptions extends PackagerOptions, PublishOptions {
  }

  export function build(options?: BuildOptions): Promise<void>
}

declare module 'electron-builder/out/codeSign' {
  import { Promise as BluebirdPromise } from "bluebird"

  export interface CodeSigningInfo {
    cscName: string
    cscKeychainName?: string
  }

  export function generateKeychainName(): string

  export function createKeychain(keychainName: string, cscLink: string, cscKeyPassword: string, csaLink?: string): Promise<CodeSigningInfo>

  export function sign(path: string, options: CodeSigningInfo): BluebirdPromise<any>

  export function deleteKeychain(keychainName: string, ignoreNotFound?: boolean): BluebirdPromise<any>

  export function downloadCertificate(cscLink: string): Promise<string>
}

declare module 'electron-builder/out/errorMessages' {
  export const buildIsMissed: string
  export const authorEmailIsMissed: string
}

declare module 'electron-builder/out/gitHubPublisher' {
  import { Release } from "gh-release"

  export interface Publisher {
    upload(path: string): Promise<any>
  }

  export interface PublishOptions {
    publish?: "onTag" | "onTagOrDraft" | "always" | "never"
    githubToken?: string
  }

  export class GitHubPublisher implements Publisher {
    readonly releasePromise: Promise<Release>
    constructor(owner: string, repo: string, version: string, token: string, createReleaseIfNotExists?: boolean)
    upload(path: string): Promise<void>
    deleteRelease(): Promise<void>
  }
}

declare module 'electron-builder/out/gitHubRequest' {
  import { RequestOptions } from "https"
  import { IncomingMessage, ClientRequest } from "http"
  import { Promise as BluebirdPromise } from "bluebird"

  export function gitHubRequest<T>(path: string, token: string, data?: {
    [name: string]: any
  }, method?: string): BluebirdPromise<T>

  export function doGitHubRequest<T>(options: RequestOptions, token: string, requestProcessor: (request: ClientRequest, reject: (error: Error) => void) => void): BluebirdPromise<T>

  export class HttpError extends Error {
    response: IncomingMessage
    description: any
    constructor(response: IncomingMessage, description?: any)
  }
}

declare module 'electron-builder/out/httpRequest' {
  import { ClientRequest } from "http"
  import { Promise as BluebirdPromise } from "bluebird"
  export const download: (arg1: string, arg2: string) => BluebirdPromise<{}>

  export function addTimeOutHandler(request: ClientRequest, callback: (error: Error | string) => void): void
}

declare module 'electron-builder/' {
  export { Packager } from "electron-builder/out/packager"
  export { PackagerOptions } from "electron-builder/out/platformPackager"
  export { AppMetadata, DevMetadata, Platform, getProductName } from "electron-builder/out/metadata"

  export function init(): any
}

declare module 'electron-builder/out/linuxPackager' {
  import { PlatformPackager, BuildInfo } from "electron-builder/out/platformPackager"
  import { Platform } from "electron-builder/out/metadata"

  export class LinuxPackager extends PlatformPackager<DebOptions> {
    constructor(info: BuildInfo)
    protected readonly platform: Platform
    packageInDistributableFormat(outDir: string, appOutDir: string, arch: string): Promise<any>
  }

  export interface DebOptions {
    name: string
    comment: string
    maintainer: string
    /**
     * .desktop file template
     */
    desktop?: string
    afterInstall?: string
    afterRemove?: string
    compression?: string
  }
}

declare module 'electron-builder/out/macPackager' {
  import { PlatformPackager, BuildInfo } from "electron-builder/out/platformPackager"
  import { Platform, PlatformSpecificBuildOptions } from "electron-builder/out/metadata"
  import { CodeSigningInfo } from "electron-builder/out/codeSign"

  export interface OsXBuildOptions extends PlatformSpecificBuildOptions, appdmg.Specification {
  }

  export default class MacPackager extends PlatformPackager<OsXBuildOptions> {
    codeSigningInfo: Promise<CodeSigningInfo>
    constructor(info: BuildInfo, cleanupTasks: Array<() => Promise<any>>)
    protected readonly platform: Platform
    pack(platform: string, outDir: string, appOutDir: string, arch: string): Promise<any>
    packageInDistributableFormat(outDir: string, appOutDir: string): Promise<any>
  }
}

declare module 'electron-builder/out/metadata' {
  
  export interface AppMetadata extends Metadata {
    readonly version: string
    /**
     * The application name
     **/
    readonly name: string
    /**
     * As {@link AppMetadata#name}, but allows you to specify a product name for your executable which contains spaces and other special characters
     * not allowed in the [name property]{@link https://docs.npmjs.com/files/package.json#name}.
     */
    readonly productName?: string
    readonly description: string
    readonly author: AuthorMetadata
    readonly build: BuildMetadata
  }

  export function getProductName(metadata: AppMetadata): string

  export interface DevMetadata extends Metadata {
    readonly build?: DevBuildMetadata
    readonly directories?: MetadataDirectories
  }

  export interface BuildMetadata {
    readonly "app-bundle-id": string
    readonly "app-category-type": string
    readonly iconUrl: string
    /**
     * See {@link AppMetadata#productName}.
     */
    readonly productName?: string
  }

  export interface RepositoryInfo {
    readonly url: string
  }

  export interface Metadata {
    readonly repository: string | RepositoryInfo
  }

  export interface AuthorMetadata {
    readonly name: string
    readonly email: string
  }

  export interface MetadataDirectories {
    readonly buildResources?: string
  }

  export interface DevBuildMetadata {
    readonly osx?: appdmg.Specification
    readonly win?: any
    readonly linux?: any
    readonly extraResources?: Array<string>
  }

  export interface PlatformSpecificBuildOptions {
    readonly extraResources?: Array<string>
  }

  export class Platform {
    name: string
    buildConfigurationKey: string
    static OSX: Platform
    static LINUX: Platform
    static WINDOWS: Platform
    constructor(name: string, buildConfigurationKey: string)
    toString(): string
    static fromNodePlatform(name: string): Platform
  }
}

declare module 'electron-builder/out/packager' {
  import { EventEmitter } from "events"
  import { InfoRetriever } from "electron-builder/out/repositoryInfo"
  import { AppMetadata, Platform, DevMetadata } from "electron-builder/out/metadata"
  import { PackagerOptions, BuildInfo } from "electron-builder/out/platformPackager"

  export class Packager implements BuildInfo {
    options: PackagerOptions
    repositoryInfo: InfoRetriever
    readonly projectDir: string
    readonly appDir: string
    metadata: AppMetadata
    devMetadata: DevMetadata
    electronVersion: string
    readonly eventEmitter: EventEmitter
    constructor(options: PackagerOptions, repositoryInfo?: InfoRetriever)
    artifactCreated(handler: (file: string, platform: Platform) => void): Packager
    readonly devPackageFile: string
    build(): Promise<any>
  }

  export function normalizeArchs(platform: string, arch?: string): string[]

  export function normalizePlatforms(platforms: Array<string>): Array<string>
}

declare module 'electron-builder/out/platformPackager' {
  import { InfoRetriever, ProjectMetadataProvider } from "electron-builder/out/repositoryInfo"
  import { AppMetadata, DevMetadata, Platform, PlatformSpecificBuildOptions } from "electron-builder/out/metadata"
  import EventEmitter = NodeJS.EventEmitter

  export interface PackagerOptions {
    arch?: string
    dist?: boolean
    githubToken?: string
    sign?: string
    platform?: Array<string>
    target?: Array<string>
    appDir?: string
    projectDir?: string
    cscLink?: string
    csaLink?: string
    cscKeyPassword?: string
  }

  export interface BuildInfo extends ProjectMetadataProvider {
    options: PackagerOptions
    devMetadata: DevMetadata
    projectDir: string
    appDir: string
    electronVersion: string
    repositoryInfo: InfoRetriever
    eventEmitter: EventEmitter
  }

  export abstract class PlatformPackager<DC extends PlatformSpecificBuildOptions> implements ProjectMetadataProvider {
    protected info: BuildInfo
    protected readonly options: PackagerOptions
    protected readonly projectDir: string
    protected readonly buildResourcesDir: string
    readonly metadata: AppMetadata
    readonly devMetadata: DevMetadata
    customBuildOptions: DC
    readonly appName: string
    protected readonly abstract platform: Platform
    constructor(info: BuildInfo)
    protected readonly relativeBuildResourcesDirname: string
    protected dispatchArtifactCreated(file: string): void
    pack(platform: string, outDir: string, appOutDir: string, arch: string): Promise<any>
    abstract packageInDistributableFormat(outDir: string, appOutDir: string, arch: string): Promise<any>
  }
}

declare module 'electron-builder/out/platforms' {
   var _default: (platform: string) => any
  export = _default
}

declare module 'electron-builder/out/promise' {
  import { Promise as BluebirdPromise } from "bluebird"

  export function printErrorAndExit(error: Error): void

  export function executeFinally(promise: Promise<any>, task: (errorOccurred: boolean) => Promise<any>): Promise<any>

  export class NestedError extends Error {
    constructor(errors: Array<Error>, message?: string)
  }

  export function all(promises: Array<Promise<any>>): BluebirdPromise<any>
}

declare module 'electron-builder/out/promisifed-fs' {
  import { Promise as BluebirdPromise } from "bluebird"

  export function readText(file: string): BluebirdPromise<string>
}

declare module 'electron-builder/out/repositoryInfo' {
  import { Info } from "hosted-git-info"
  import { AppMetadata, Metadata } from "electron-builder/out/metadata"

  export interface ProjectMetadataProvider {
    metadata: AppMetadata
    devMetadata: Metadata
  }

  export interface RepositorySlug {
    user: string
    project: string
  }

  export class InfoRetriever {
    _info: Promise<Info>
    getInfo(provider?: ProjectMetadataProvider): Promise<Info>
  }
}

declare module 'electron-builder/out/util' {
  import { Promise as BluebirdPromise } from "bluebird"
  export const log: (message?: any, ...optionalParams: any[]) => void
  export const DEFAULT_APP_DIR_NAME: string
  export const commonArgs: any[]
  export const readPackageJson: (arg1: string) => BluebirdPromise<any>

  export function installDependencies(appDir: string, electronVersion: string, arch?: string, command?: string): BluebirdPromise<any>

  export interface BaseExecOptions {
    cwd?: string
    env?: any
    stdio?: any
  }

  export interface ExecOptions extends BaseExecOptions {
    customFds?: any
    encoding?: string
    timeout?: number
    maxBuffer?: number
    killSignal?: string
  }

  export interface SpawnOptions extends BaseExecOptions {
    custom?: any
    detached?: boolean
  }

  export function exec(file: string, args?: string[], options?: ExecOptions): BluebirdPromise<Buffer[]>

  export function spawn(command: string, args?: string[], options?: SpawnOptions): BluebirdPromise<any>

  export function getElectronVersion(packageData: any, filePath: string): string
}

declare module 'electron-builder/out/winPackager' {
  import { PlatformPackager, BuildInfo } from "electron-builder/out/platformPackager"
  import { Platform, PlatformSpecificBuildOptions } from "electron-builder/out/metadata"

  export interface WinBuildOptions extends PlatformSpecificBuildOptions {
    readonly certificateFile?: string
    readonly certificatePassword?: string
    readonly icon?: string
    readonly iconUrl?: string
  }

  export default class WinPackager extends PlatformPackager<WinBuildOptions> {
    certFilePromise: Promise<string>
    isNsis: boolean
    constructor(info: BuildInfo, cleanupTasks: Array<() => Promise<any>>)
    protected readonly platform: Platform
    pack(platform: string, outDir: string, appOutDir: string, arch: string): Promise<any>
    packageInDistributableFormat(outDir: string, appOutDir: string, arch: string): Promise<any>
  }
}


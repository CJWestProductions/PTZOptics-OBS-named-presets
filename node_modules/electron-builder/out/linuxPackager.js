"use strict";

const path = require("path");
const bluebird_1 = require("bluebird");
const platformPackager_1 = require("./platformPackager");
const metadata_1 = require("./metadata");
const tmp_1 = require("tmp");
const util_1 = require("./util");
const fs_extra_p_1 = require("fs-extra-p");
const template = require("lodash.template");
//noinspection JSUnusedLocalSymbols
const __awaiter = require("./awaiter");
const tmpDir = bluebird_1.Promise.promisify(tmp_1.dir);
class LinuxPackager extends platformPackager_1.PlatformPackager {
    constructor(info) {
        super(info);
        this.debOptions = Object.assign({
            name: this.metadata.name,
            comment: this.metadata.description
        }, this.customBuildOptions);
        if (this.options.dist) {
            const tempDir = tmpDir({
                unsafeCleanup: true,
                prefix: "electron-builder-"
            });
            this.packageFiles = this.computePackageFiles(tempDir);
            this.scriptFiles = this.createScripts(tempDir);
        }
    }
    get platform() {
        return metadata_1.Platform.LINUX;
    }
    computePackageFiles(tempDirPromise) {
        return __awaiter(this, void 0, void 0, function* () {
            const tempDir = yield tempDirPromise;
            const promises = [];
            if (this.customBuildOptions == null || this.customBuildOptions.desktop == null) {
                promises.push(this.computeDesktopIconPath(tempDir));
            }
            promises.push(this.computeDesktop(tempDir));
            return Array.prototype.concat.apply([], (yield bluebird_1.Promise.all(promises)));
        });
    }
    computeDesktop(tempDir) {
        return __awaiter(this, void 0, void 0, function* () {
            const tempFile = path.join(tempDir, this.appName + ".desktop");
            yield fs_extra_p_1.outputFile(tempFile, this.debOptions.desktop || `[Desktop Entry]
Name=${ this.appName }
Comment=${ this.debOptions.comment }
Exec="${ this.appName }"
Terminal=false
Type=Application
Icon=${ this.metadata.name }
`);
            return [`${ tempFile }=/usr/share/applications/${ this.appName }.desktop`];
        });
    }
    // must be name without spaces and other special characters, but not product name used
    computeDesktopIconPath(tempDir) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const mappings = [];
                const pngIconsDir = path.join(this.buildResourcesDir, "icons");
                for (let file of yield fs_extra_p_1.readdir(pngIconsDir)) {
                    if (file.endsWith(".png") || file.endsWith(".PNG")) {
                        // If parseInt encounters a character that is not a numeral in the specified radix,
                        // it returns the integer value parsed up to that point
                        try {
                            const size = parseInt(file, 10);
                            if (size > 0) {
                                mappings.push(`${ pngIconsDir }/${ file }=/usr/share/icons/hicolor/${ size }x${ size }/apps/${ this.metadata.name }.png`);
                            }
                        } catch (e) {
                            console.error(e);
                        }
                    }
                }
                return mappings;
            } catch (e) {
                return this.createFromIcns(tempDir);
            }
        });
    }
    createFromIcns(tempDir) {
        return __awaiter(this, void 0, void 0, function* () {
            const outputs = yield util_1.exec("icns2png", ["-x", "-o", tempDir, path.join(this.buildResourcesDir, "icon.icns")]);
            const output = outputs[0].toString();
            util_1.log(output);
            const gm = require("gm");
            const imagePath = path.join(tempDir, "icon_256x256x32.png");
            function resize(size) {
                return new bluebird_1.Promise((resolve, reject) => {
                    gm(imagePath).resize(size, size).write(path.join(tempDir, `icon_${ size }x${ size }x32.png`), error => error == null ? resolve() : reject(error));
                });
            }
            const promises = [resize(24), resize(96)];
            if (!(output.indexOf("ih32") !== -1)) {
                promises.push(resize(48));
            }
            if (!(output.toString().indexOf("icp6") !== -1)) {
                promises.push(resize(64));
            }
            if (!(output.indexOf("it32") !== -1)) {
                promises.push(resize(128));
            }
            yield bluebird_1.Promise.all(promises);
            const appName = this.metadata.name;
            function createMapping(size) {
                return `${ tempDir }/icon_${ size }x${ size }x32.png=/usr/share/icons/hicolor/${ size }x${ size }/apps/${ appName }.png`;
            }
            return [createMapping("16"), createMapping("24"), createMapping("32"), createMapping("48"), createMapping("64"), createMapping("96"), createMapping("128"), createMapping("256"), createMapping("512")];
        });
    }
    createScripts(tempDirPromise) {
        return __awaiter(this, void 0, void 0, function* () {
            const tempDir = yield tempDirPromise;
            const defaultTemplatesDir = path.join(__dirname, "..", "templates", "linux");
            const templateOptions = Object.assign({
                // old API compatibility
                executable: this.appName
            }, this.debOptions);
            const afterInstallTemplate = this.debOptions.afterInstall || path.join(defaultTemplatesDir, "after-install.tpl");
            const afterInstallFilePath = writeConfigFile(tempDir, afterInstallTemplate, templateOptions);
            const afterRemoveTemplate = this.debOptions.afterRemove || path.join(defaultTemplatesDir, "after-remove.tpl");
            const afterRemoveFilePath = writeConfigFile(tempDir, afterRemoveTemplate, templateOptions);
            return yield bluebird_1.Promise.all([afterInstallFilePath, afterRemoveFilePath]);
        });
    }
    packageInDistributableFormat(outDir, appOutDir, arch) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.buildDeb(this.debOptions, outDir, appOutDir, arch).then(it => this.dispatchArtifactCreated(it));
        });
    }
    buildDeb(options, outDir, appOutDir, arch) {
        return __awaiter(this, void 0, void 0, function* () {
            const archName = arch === "ia32" ? "i386" : "amd64";
            const target = "deb";
            const destination = path.join(outDir, `${ this.metadata.name }-${ this.metadata.version }-${ archName }.${ target }`);
            const scripts = yield this.scriptFiles;
            yield util_1.exec("fpm", ["-s", "dir", "-t", target, "--architecture", archName, "--rpm-os", "linux", "--name", this.metadata.name, "--force", "--after-install", scripts[0], "--after-remove", scripts[1], "--description", options.comment, "--maintainer", options.maintainer || `${ this.metadata.author.name } <${ this.metadata.author.email }>`, "--version", this.metadata.version, "--package", destination, "--deb-compression", options.compression || "xz", appOutDir + "/=/opt/" + this.appName].concat((yield this.packageFiles)));
            return destination;
        });
    }
}
exports.LinuxPackager = LinuxPackager;
function writeConfigFile(tempDir, templatePath, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = template((yield fs_extra_p_1.readFile(templatePath, "utf8")), {
            // set interpolate explicitly to avoid troubles with templating of installer.nsi.tpl
            interpolate: /<%=([\s\S]+?)%>/g
        })(options);
        const outputPath = path.join(tempDir, path.basename(templatePath, ".tpl"));
        yield fs_extra_p_1.outputFile(outputPath, config);
        return outputPath;
    });
}
//# sourceMappingURL=linuxPackager.js.map
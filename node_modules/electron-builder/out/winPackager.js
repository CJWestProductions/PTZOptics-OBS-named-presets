"use strict";

const codeSign_1 = require("./codeSign");
const bluebird_1 = require("bluebird");
const platformPackager_1 = require("./platformPackager");
const metadata_1 = require("./metadata");
const path = require("path");
const util_1 = require("./util");
const fs_extra_p_1 = require("fs-extra-p");
//noinspection JSUnusedLocalSymbols
const __awaiter = require("./awaiter");
class WinPackager extends platformPackager_1.PlatformPackager {
    constructor(info, cleanupTasks) {
        super(info);
        // we are not going to support build both nsis and squirrel
        this.isNsis = this.options.target != null && this.options.target.indexOf("nsis") !== -1;
        if (this.isNsis) {
            // it is not an optimization, win.js cannot be runned in highly concurrent environment and we get
            // "Error: EBUSY: resource busy or locked, unlink 'C:\Users\appveyor\AppData\Local\Temp\1\icon.ico'"
            // on appveyor (well, yes, it is a Windows bug)
            // Because NSIS support will be dropped some day, correct solution is not implemented
            const iconPath = this.customBuildOptions == null ? null : this.customBuildOptions.icon;
            require("../lib/win").copyAssetsToTmpFolder(iconPath || path.join(this.buildResourcesDir, "icon.ico"));
        }
        // https://developer.mozilla.org/en-US/docs/Signing_an_executable_with_Authenticode
        // https://github.com/Squirrel/Squirrel.Windows/pull/505
        if (this.options.cscLink != null && this.options.cscKeyPassword != null && process.platform !== "darwin") {
            this.certFilePromise = codeSign_1.downloadCertificate(this.options.cscLink).then(path => {
                cleanupTasks.push(() => fs_extra_p_1.deleteFile(path, true));
                return path;
            });
        } else {
            this.certFilePromise = bluebird_1.Promise.resolve(null);
        }
    }
    get platform() {
        return metadata_1.Platform.WINDOWS;
    }
    pack(platform, outDir, appOutDir, arch) {
        if (this.options.dist && !this.isNsis) {
            const installerOut = this.computeDistOut(outDir, arch);
            util_1.log("Removing %s", installerOut);
            return bluebird_1.Promise.all([super.pack(platform, outDir, appOutDir, arch), fs_extra_p_1.emptyDir(installerOut)]);
        } else {
            return super.pack(platform, outDir, appOutDir, arch);
        }
    }
    computeDistOut(outDir, arch) {
        return path.join(outDir, (this.isNsis ? "nsis" : "win") + (arch === "x64" ? "-x64" : ""));
    }
    packageInDistributableFormat(outDir, appOutDir, arch) {
        return __awaiter(this, void 0, void 0, function* () {
            let iconUrl = this.metadata.build.iconUrl;
            if (!iconUrl) {
                if (this.customBuildOptions != null) {
                    iconUrl = this.customBuildOptions.iconUrl;
                }
                if (!iconUrl) {
                    if (this.info.repositoryInfo != null) {
                        const info = yield this.info.repositoryInfo.getInfo(this);
                        if (info != null) {
                            iconUrl = `https://raw.githubusercontent.com/${ info.user }/${ info.project }/master/${ this.relativeBuildResourcesDirname }/icon.ico`;
                        }
                    }
                    if (!iconUrl) {
                        throw new Error("iconUrl is not specified, please see https://github.com/loopline-systems/electron-builder#in-short");
                    }
                }
            }
            const certificateFile = yield this.certFilePromise;
            const version = this.metadata.version;
            const installerOutDir = this.computeDistOut(outDir, arch);
            const archSuffix = arch === "x64" ? "" : "-" + arch;
            const options = Object.assign({
                name: this.metadata.name,
                productName: this.appName,
                exe: this.appName + ".exe",
                title: this.appName,
                appDirectory: appOutDir,
                outputDirectory: installerOutDir,
                version: version,
                description: this.metadata.description,
                authors: this.metadata.author.name,
                iconUrl: iconUrl,
                setupIcon: path.join(this.buildResourcesDir, "icon.ico"),
                certificateFile: certificateFile,
                certificatePassword: this.options.cscKeyPassword,
                fixUpPaths: false,
                usePackageJson: false
            }, this.customBuildOptions);
            // we use metadata.name instead of appName because appName can contains unsafe chars
            const installerExePath = path.join(installerOutDir, this.metadata.name + "Setup-" + version + archSuffix + ".exe");
            if (this.isNsis) {
                return yield this.nsis(options, installerExePath);
            }
            try {
                yield require("electron-winstaller-fixed").createWindowsInstaller(options);
            } catch (e) {
                if (!(e.message.indexOf("Unable to set icon") !== -1)) {
                    throw e;
                } else {
                    let fileInfo;
                    try {
                        fileInfo = yield fs_extra_p_1.stat(options.setupIcon);
                    } catch (e) {
                        throw new Error("Please specify correct setupIcon, file " + options.setupIcon + " not found");
                    }
                    if (fileInfo.isDirectory()) {
                        throw new Error("Please specify correct setupIcon, " + options.setupIcon + " is a directory");
                    }
                }
            }
            const releasesFile = path.join(installerOutDir, "RELEASES");
            const nupkgPathOriginal = this.metadata.name + "-" + version + "-full.nupkg";
            const nupkgPathWithArch = this.metadata.name + "-" + version + archSuffix + "-full.nupkg";
            function changeFileNameInTheReleasesFile() {
                return __awaiter(this, void 0, void 0, function* () {
                    const data = (yield fs_extra_p_1.readFile(releasesFile, "utf8")).replace(new RegExp(" " + nupkgPathOriginal + " ", "g"), " " + nupkgPathWithArch + " ");
                    debugger;
                    yield fs_extra_p_1.writeFile(releasesFile, data);
                });
            }
            const promises = [fs_extra_p_1.rename(path.join(installerOutDir, "Setup.exe"), installerExePath).then(it => this.dispatchArtifactCreated(it))];
            if (archSuffix === "") {
                this.dispatchArtifactCreated(path.join(installerOutDir, nupkgPathOriginal));
                this.dispatchArtifactCreated(path.join(installerOutDir, "RELEASES"));
            } else {
                promises.push(fs_extra_p_1.rename(path.join(installerOutDir, nupkgPathOriginal), path.join(installerOutDir, nupkgPathWithArch)).then(it => this.dispatchArtifactCreated(it)));
                promises.push(changeFileNameInTheReleasesFile().then(() => fs_extra_p_1.copy(releasesFile, path.join(installerOutDir, "RELEASES-ia32"))).then(it => this.dispatchArtifactCreated(it)));
            }
            yield bluebird_1.Promise.all(promises);
        });
    }
    nsis(options, installerFile) {
        return __awaiter(this, void 0, void 0, function* () {
            const build = require("../lib/win").init().build;
            // nsis cannot create dir
            yield fs_extra_p_1.emptyDir(options.outputDirectory);
            return yield bluebird_1.Promise.promisify(build)(Object.assign(options, {
                log: console.log,
                appPath: options.appDirectory,
                out: options.outputDirectory,
                platform: "win32",
                outFile: installerFile,
                copyAssetsToTmpFolder: false,
                config: {
                    win: Object.assign({
                        title: options.title,
                        version: options.version,
                        icon: options.setupIcon,
                        publisher: options.authors,
                        verbosity: 2
                    }, this.customBuildOptions)
                }
            }));
        });
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = WinPackager;
//# sourceMappingURL=winPackager.js.map